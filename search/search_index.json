{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Index","text":"<ol> <li>Switches</li> <li>Routers</li> <li>Network Models</li> <li>Upper Layers</li> <li>Network Tier-Based Architecture</li> <li>Hybrid-Cloud</li> <li>Ethernet Cables</li> <li>Computer Networks and the Internet</li> <li>Application Layer</li> <li>Transport layer</li> <li>IP addresses</li> <li>Subnet Mask</li> <li>Subnetting (GPT notes)</li> </ol>"},{"location":"notes/Application%20Layer/","title":"Application Layer","text":""},{"location":"notes/Application%20Layer/#principles","title":"Principles","text":"<ul> <li>Core principle of network dev is writing application that run on different end systems and communicate to each other over the network</li> <li>Example<ul> <li>Web application -&gt; browser program running on the host's end and the web server program running in the web server host.</li> </ul> </li> <li>You need to write a program that runs on both end systems</li> </ul>"},{"location":"notes/Application%20Layer/#network-application-architectures","title":"Network Application Architectures","text":""},{"location":"notes/Application%20Layer/#client-server","title":"Client server","text":"<ul> <li>Always on host - server which services requests from other hosts - clients</li> <li>Clients don't interact with each other, they interact directly to the server</li> <li>For larger scale applications w/ large clients, big &amp; maintained servers are used - data centers.</li> <li>Servers have a fixed address and are always on, so clients can contact the server by sending packets to the address at all times.</li> </ul>"},{"location":"notes/Application%20Layer/#p2p","title":"P2P","text":"<ul> <li>No contact with any dedicated servers</li> <li>Clients are interconnected with each other and directly interact with each other</li> <li>Clients are controlled by the users themselves</li> <li>P2P is self-scalable</li> <li>For example, in a P2P file-sharing application, although each peer generates workload by requesting files, each peer also adds service capacity to the system by distributing files to other peers.</li> </ul>"},{"location":"notes/Application%20Layer/#processes","title":"Processes","text":""},{"location":"notes/Application%20Layer/#client-server-process","title":"Client Server Process","text":"<ul> <li>In the context of a communication session between a pair of processes, the process that initiates the communication (that is, initially contacts the other process at the beginning of the session) is labeled as the client. The process that waits to be contacted to begin the session is the server.</li> </ul>"},{"location":"notes/Application%20Layer/#interface-between-process-and-computer-network","title":"Interface between Process and computer network","text":"<ul> <li>Any message sent from one process to another must go through the underlying network</li> <li>Messages are sent to and fro through a software interface called sockets</li> <li>Socket is the interface between application layer and transport layer, commonly also called as Application Programming Interface.</li> <li>Application developer has full control over the application layer side of the socket but little control of the transport layer side of the socket.</li> </ul>"},{"location":"notes/Application%20Layer/#addressing-processes","title":"Addressing Processes","text":"<ul> <li>In order for a process to send message to another process on another host, the receiving process needs to have an address.</li> <li>To identify receiving process, two things are needed<ol> <li>Address of the host (IP address)</li> <li>Identifier that specified the receiving process in the destination host. (destination port number).</li> </ol> </li> </ul>"},{"location":"notes/Application%20Layer/#transport-services-avl-to-applications","title":"Transport services (avl to applications)","text":"<ul> <li>Reliable data transfer<ul> <li>To support application there must be a protocol that can ensure data sent from one client is sent and received completely by the client on the other end.</li> <li>When a transport-layer protocol doesn\u2019t provide reliable data transfer, some of the data sent by the sending process may never arrive at the receiving process. This may be acceptable for loss-tolerant applications</li> </ul> </li> <li>Throughput</li> <li>Timing</li> <li>Security</li> </ul>"},{"location":"notes/Application%20Layer/#transport-services-provided-by-internet","title":"Transport services (provided by internet)","text":"<ul> <li>TCP<ul> <li>Congestion control mechanism</li> <li>Connection Oriented</li> <li>Reliable data transfer</li> </ul> </li> <li>Enhanced TCP with SSL</li> <li>UDP<ul> <li>Connectionless oriented</li> <li>No congestion protocol</li> <li>lightweight and minimal</li> </ul> </li> </ul>"},{"location":"notes/Application%20Layer/#application-layer-protocols","title":"Application layer protocols","text":"<p>Application layer protocols define how an applications processes run on different end systems.</p>"},{"location":"notes/Application%20Layer/#web-http","title":"Web &amp; HTTP","text":""},{"location":"notes/Application%20Layer/#http-overview","title":"HTTP Overview","text":"<ul> <li>Two implementations of HTTP, server and client</li> <li>Web server -&gt; server and web browsers -&gt; client </li> <li>First TCP connection b/w client and server is established and then communication is done through their socket interface</li> <li>HTTP doesn't need to worry about the data being lost or anything, TCP handles it</li> <li>HTTP is a stateless protocol</li> </ul>"},{"location":"notes/Application%20Layer/#persistent-non-persistent","title":"Persistent &amp; Non Persistent","text":"<ul> <li>Persistent - All req and res sent in one TCP connection</li> <li>Non Persistent - New connection made for every req and res</li> </ul>"},{"location":"notes/Application%20Layer/#http-connections","title":"HTTP connections","text":"<p>Round trip time - Time taken for packet to travel from client to server and back to client. RTT includes packet-propagation delays, packet queuing delays in intermediate routers and switches, and packet-processing delays.</p>"},{"location":"notes/Application%20Layer/#http-w-non-persistent-connections","title":"HTTP w/ non-persistent connections","text":"<ul> <li>1 RTT - Send TCP initiation request sent, server ack sent</li> <li>1 RTT - HTTP req w/ client ack sent, html file sent</li> <li>New connection for each requested object.</li> <li>TCP buffers and variables must be kept in both client and server, this can be a burden to both.</li> </ul>"},{"location":"notes/Application%20Layer/#http-w-persistent-connection","title":"HTTP w/ persistent connection","text":"<ul> <li>1 RTT - Req sent, HTML sent back.</li> <li>TCP connection is made and left on until there isn't any communication/req for a while (this can be configured)</li> <li>multiple Web pages residing on the same server can be sent from the server to the same client over a single persistent TCP connection. These requests for objects can be made back-to-back, without waiting for replies to pending requests (pipelining)</li> <li>Recent HTTP 1.1 allows multiple server requests to be interleaved in the same connection. It has a priority mechanism which selects which request to respond to.</li> </ul>"},{"location":"notes/Application%20Layer/#http-message-format","title":"HTTP Message format","text":"<p>There's two types of messages, requests and responses</p>"},{"location":"notes/Application%20Layer/#request-message","title":"Request Message","text":"<pre><code>GET /somedir/index.html HTTP/1.1  #request line\n# following lines are header lines\nHost: www.somedir.com # specifies where the object recides\nConnection: close # close the tcp connection after sending this request\nUser-agent: Mozilla/5.0\nAccept-language: fr\n</code></pre> <p><code>HEAD</code> method is almost similar to <code>GET</code> but it only responds with an HTTP msg but leaves out the requested object.</p>"},{"location":"notes/Application%20Layer/#response-message","title":"Response Message","text":"<pre><code>HTTP/1.1 200 OK\nConnection: close\nData: ...\nServer: ...\nLast-Modified: ...\nContent-Length: ...\nContent-Type: ...\n</code></pre>"},{"location":"notes/Application%20Layer/#cookies","title":"Cookies","text":"<p>HTTP servers are stateless, cookies help provide some sort of state to HTTP servers. Cookies help us keep track of user information.</p> <p>Four comp. of the cookie tech 1. Cookie header line in HTTP req msg 2. Cookie header line in HTTP res msg 3. Cookie file stored in users end system and managed by the browser 4. Backend database at the website.</p> <p>Coookies create a user session layer on top of the stateless HTTP. When visiting a site for the first time, the server will respond with a msg to browser with a msg,</p> <p><code>Set Cookie: 1679</code></p> <p>When revisiting, the browser sends requests with the cookie file,</p> <p><code>Cookie: 1679</code></p> <p>![[Pasted image 20240824102952.png]]</p>"},{"location":"notes/Application%20Layer/#web-caching","title":"Web Caching","text":"<ul> <li>aka Proxy server</li> <li>satisfies the webs http req on behalf of the web server</li> <li>has its own disk storage space &amp; keeps copies of recently requested objects</li> <li>both client &amp; server at the same time</li> <li>Usually purchased and installed by the ISP's</li> <li>ISP's purchase and install these servers in their network and configure their browsers to be directed to the proxy servers.</li> </ul> <p>Pros of web caching 1. Reduces traffic on main web server 2. Reduce response time 3. Improve performance of applications</p> <p>![[Pasted image 20240824145556.png]]</p>"},{"location":"notes/Application%20Layer/#content-distribution-networks","title":"Content Distribution Networks","text":"<p>Is another form of web caching where the ISP needs to only purchase a specific domain and need not worry about setting up an actual server.</p> <p>A CDN company installs many caches throughout the internet. there are shared CDNS &amp; dedicated CDNS.</p>"},{"location":"notes/Application%20Layer/#conditional-get","title":"Conditional GET","text":"<p>This is another form of an HTTP request which is required to check whether the existing object in the web cache is of the latest version or not.</p> <p>Once the web cache is stored, and it's accessed some time later, the web cache server will send a request to the web server as such</p> <pre><code>GET /fruit/kiwi.gif HTTP/1.1 \nHost: www.exotiquecuisine.com \nIf-modified-since: Wed, 9 Sep 2015 09:23:24\n</code></pre> <p>The <code>If-modified-since</code> is compared with the <code>Last-modified</code> header to come across any updates to the object.</p> <p>If it's not modified, the server will send this back to the proxy server</p> <pre><code>HTTP/1.1 304 Not Modified \nDate: Sat, 10 Oct 2015 15:39:29 \nServer: Apache/1.3.0 (Unix)\n</code></pre> <p>And if the object is modified,</p> <pre><code>HTTP/1.1 200 OK \nDate: Sat, 10 Oct 2015 15:39:29 \nServer: Apache/1.3.0 (Unix) \nLast-Modified: Sat, 10 Oct 2015 10:15:00 \nContent-Type: image/gif \nContent-Length: 1024\n</code></pre>"},{"location":"notes/Application%20Layer/#email-and-the-internet","title":"Email and the internet","text":"<p>Terminologies - User agents - Sends the mail to the mail server - Mail Servers - Stores the mail in its Queue and sends the mail to the other mail servers when needed. - Simple Mail Transfer Protocol (SMTP) - Application Layer protocol which is supported by TCP for reliable data transfer</p> <p>Flow of mail</p> <pre><code>(SMTP Client) Senders user agent -&gt; Senders Mail server -&gt; (SMTP Server) Recipient's Mail Server -&gt; Recipients Mail Box\n</code></pre> <p>![[Pasted image 20240825120924.png]]</p>"},{"location":"notes/Application%20Layer/#smtp","title":"SMTP","text":"<p>Facts - Much older than HTTP - Data is sent to &amp; fro in 7 bit ASCII format. While sending it's encoded by client and while receiving its decoded by server. - SMTP first initializes TCP connection with other mail server. - No intermediate mail servers are used for long distances.</p> <p>Process - Client SMTP has TCP establish a connection (port 25) with the Server SMTP - Client and server perform three-way handshaking where the client also mentions the senders and recipients email address. - The reliable data transfer is left off to TCP. - Process is repeated if there are more messages over the same connection or the connection is closed.</p> <p>![[Pasted image 20240825120936.png]]</p> <p>Example communication</p> <pre><code>S:\u00a0\u00a0220 hamburger.edu \nC:\u00a0\u00a0HELO crepes.fr # HELO, MAIL, RCPT TO, DATA, QUIT are part of the dialogue\nS:\u00a0\u00a0250 Hello crepes.fr, pleased to meet you \nC:\u00a0\u00a0MAIL FROM: &lt;alice@crepes.fr&gt;\nS:\u00a0\u00a0250 alice@crepes.fr ... Sender ok \nC:\u00a0\u00a0RCPT TO: &lt;bob@hamburger.edu&gt;\nS:\u00a0\u00a0250 bob@hamburger.edu ... Recipient ok \nC:\u00a0\u00a0DATA \nS:\u00a0\u00a0354 Enter mail, end with \u201d.\u201d on a line by itself \nC:\u00a0\u00a0Do you like ketchup? \nC:\u00a0\u00a0How about pickles? \nC:\u00a0\u00a0. # end of message, in ASCII -&gt; CRLF (carriage return &amp; line feed)\nS:\u00a0\u00a0250 Message accepted for delivery \nC:\u00a0\u00a0QUIT \nS:\u00a0\u00a0221 hamburger.edu closing connection\n</code></pre>"},{"location":"notes/Application%20Layer/#comparison-w-http","title":"Comparison w/ HTTP","text":"HTTP SMTP Pull protocol, where the users use TCP connection to pull the info from the server Push Protocol, where the sender initiates a TCP connection to send data Doesn't need any modification to the data being transferred Data transferred must be encoded/decoded in 7-Bit ASCII format Encapsulates each object in its own HTTP msg Places all message's objects in one object ### Mail Access formats <p>Flow - Senders user agent sends the msg to its mail server. (using smtp) - Senders mail server sends msg to recipients mail server. (using smtp) - Since SMTP is a push protocol, the recipients user agent doesn't have any way to get the msg from its mail server. - Mail access protocol helps user agents pull the msg from their mail server.</p> <p>Mail access protocols - IMAP - POP3 - HTTP</p> <ol> <li>POP3<ul> <li>POP3 begins when the client makes a TCP connection to the mail server on port 110.</li> <li>Three phases in POP3<ol> <li>Authorization - user is authorized </li> <li>Transaction - user agent retrieves messages, mark msg for deletion, remove deletion marks and obtain mail statistics</li> <li>Update - occurs after <code>quit</code> command is run</li> </ol> </li> <li>Server responds with <code>+OK</code> &amp; <code>-ERR</code></li> <li>Authorization has two principle commands, <code>user&lt;username&gt;</code> &amp; <code>pass&lt;password&gt;</code> </li> <li>Transaction phase has two methods which can be configured by the user, \"download and delete\" &amp; \"download and keep\".<ul> <li>download and delete mode allows the user to use the <code>list, retr, dele</code> commands</li> <li>in download and keep mode the user agent leaves the messages on the mail server after downloading them.</li> </ul> </li> <li>After the user issues wtv commands they want, the user runs <code>quit</code> and POP3 server enters the update phase</li> <li>This mode isn't really useful if the user is a nomad who wants to check their mails on different servers over different laptops.</li> <li>POP3 does not carry state information over sessions, it only keeps state information (i.e which mails have been marked for deletion) within a session.</li> </ul> </li> <li>IMAP<ul> <li>With POP3 one can download the mails on their local machine and maintain different folder for the mails. But this paradigm doesn't allow the user to use these mails on different machines.</li> <li>IMAP is a mail access protocol that allows the user to move mails into different folder, create new folder and move msg's from one folder to other.</li> <li>IMAP maintains state information across sessions</li> <li>Allows user to access/download only a part of a message in low bandwidth connection areas.</li> </ul> </li> </ol> <p>In web-based emails, the servers and agents now connect over HTTP. The user agent pulls emails from the mail server using HTTP rather than POP3 and IMAP. When the user wants to send an email, the user agent sends it to the mail server using HTTP. However the mail servers still send and receive messages through SMTP.</p>"},{"location":"notes/Application%20Layer/#dns-servers","title":"DNS Servers","text":"<ul> <li>Two ways to identify a host, hostname &amp; ip address. </li> <li>DNS servers help in resolving the hostnames into ip addresses so that routers/switches can operate.</li> <li>Operates on port 53 and runs over UDP</li> <li>Deployed by application layer protocols (HTTP &amp; SMTP) to resolve hostnames.</li> <li>Adds additional delay, but sometimes IP addresses are cached in nearby servers.</li> </ul> <p>DNS is a  1. Distributed database implemented in a hierarchy of DNS servers 2. Allows hosts to query the distributed database.</p> <p>Features 1. Host aliasing     - One hostname (canonical name) -&gt; multiple aliases     - DNS is invoked by application to obtain cname for a supplied alias 2. Mail server aliasing     - Similar to host aliasing, DNS is invoked by mail application to obtain cname for a supplied alias. 3. Load distribution     - Busy servers are often replicated over many servers to offload heavy traffic over to other servers. Each server runs on different end systems having different IP addresses.     - Client makes a query for a name which is mapped to several addresses, the server returns a set of addresses.      - The server follows a mechanism where for each query it rotates the set as the client will typically pick the top address in the set.</p> <p>Web server and Mail server can have the same canonical name</p>"},{"location":"notes/Application%20Layer/#overview-of-dns-working","title":"Overview of DNS working","text":"<ul> <li>Application invokes the DNS server to resolve a host name.</li> <li>DNS takes over and sends a request to the network</li> <li>All requests &amp; messages are done over UDP on port 53</li> <li>DNS server sends a reply to DNS in host side with the required mapping. </li> <li>Mapping is passed to the invoked application</li> </ul> <p>All the DNS mapping arent on one server. - Maintenance - Traffic/Load on one server - Single point of failure - Distant database of mappings</p>"},{"location":"notes/Application%20Layer/#distributed-hierarchy-system","title":"Distributed Hierarchy System","text":"<p>Since one server can't handle/have all the mappings present, there are multiple servers scattered around the world. The servers are designed in an hierarchical manner.</p> <ol> <li>Root DNS Servers<ul> <li>About 400 servers</li> <li>Provides with the IP addr of the tld server</li> </ul> </li> <li>Top Level Domain Servers<ul> <li>Each tld has it's own tld server</li> <li>Provides with the IP addr of the auth server</li> </ul> </li> <li>Authoritative Servers<ul> <li>Each organization with a public host name has to have its IP address publicly listed.</li> <li>Orgs can have their own servers or pay money to a service provider for the same.</li> </ul> </li> </ol> <p>Local DNS Server: Doesn't belong to the hierarchical system but is central to the DNS structure. ISP's set up their own local DNS servers. The addresses of these local servers is sent to the host when a host connects to the ISP. When a host makes a DNS query, the query is sent to the local DNS server, which acts a proxy, forwarding the query into the DNS server hierarchy.</p>"},{"location":"notes/Application%20Layer/#example","title":"Example","text":"<p><code>cse.nyu.edu</code> wants IP addr of -&gt; <code>gaia.cs.umass.edu.</code></p> <p>What we know, - Local DNS for <code>cse.nyu.edu</code> -&gt; <code>dns.nyu.edu</code> - Auth DNS for <code>gaia.cs.umass.edu</code> -&gt; <code>dns.umass.edu</code></p> <p>Flow =&gt;</p> <pre><code>[Host: cse.nyu.edu]\n     |\n     | (1. Send DNS Query for \"gaia.cs.umass.edu\" to Local DNS Server)\n     v\n[Local DNS Server: dns.nyu.edu]\n     |\n     | (2. Forward Query to Root DNS Server)\n     v\n[Root DNS Server]\n     |\n     | (3. Respond with IP Addresses of TLD Servers for \"edu\")\n     v\n[Local DNS Server: dns.nyu.edu]\n     |\n     | (4. Forward Query to TLD DNS Server for \"edu\")\n     v\n[TLD DNS Server for \"edu\"]\n     |\n     | (5. Respond with IP Address of Authoritative DNS Server for \"umass.edu\")\n     v\n[Local DNS Server: dns.nyu.edu]\n     |\n     | (6. Forward Query to Authoritative DNS Server: dns.umass.edu)\n     v\n[Authoritative DNS Server: dns.umass.edu]\n     |\n     | (7. Respond with IP Address of \"gaia.cs.umass.edu\")\n     v\n[Local DNS Server: dns.nyu.edu]\n     |\n     | (8. Send IP Address of \"gaia.cs.umass.edu\" back to Host: cse.nyu.edu)\n     v\n[Host: cse.nyu.edu]\n     |\n     | (9. Use IP Address to connect to \"gaia.cs.umass.edu\")\n     v\n[Establish Connection with \"gaia.cs.umass.edu\"]\n\n</code></pre> <p>The above requests are both iterative &amp; recursive.</p> <ul> <li>Iterative -&gt; All except 1</li> <li>Recursive -&gt; 1(since cse makes a request to dns for host &amp; dns resolves it all on its server)</li> </ul> <p>![[Pasted image 20240826201041.png]]</p>"},{"location":"notes/Application%20Layer/#dns-caching","title":"DNS caching","text":"<p>DNS caching plays a big role in DNS resolving. It reduces delay performance and also reduces the traffic in the network.</p> <p>DNS caching is what allows DNS servers to learn/cache IP addresses. It caches the mapping in its local memory. Since these mappings are never permanent, the saved addresses are discarded after a while.</p>"},{"location":"notes/Application%20Layer/#dns-records-and-messages","title":"DNS records and Messages","text":""},{"location":"notes/Application%20Layer/#records","title":"Records","text":"<p>Servers that implement DNS distributed servers also store resource records (rr). Each DNS reply carries one or more dns records</p> <ul> <li> <p>Structure: <code>(Name, Value, Type, TTL)</code></p> <ul> <li>TTL: time to live of the rr.</li> </ul> </li> <li> <p>Type = A</p> <ul> <li>Name is the hostname</li> <li>Value is the ip address of the host name</li> <li>Standard hostname to IP addr mapping</li> </ul> </li> <li>Type = NS<ul> <li>Name is domain</li> <li>Value is the hostname of auth dns server</li> <li>Used to route dns queries further down the chain</li> </ul> </li> <li>Type = CNAME<ul> <li>Name is the alias domain</li> <li>Value is the IP addr of the canonical name</li> </ul> </li> <li>Type = MX<ul> <li>Name is the email alias domain</li> <li>Value is the IP addr of the canonical email name</li> </ul> </li> </ul> <p>Servers can have the same alias for web servers and mail servers. To obtain either we use the specific type as mentioned above.</p>"},{"location":"notes/Application%20Layer/#messages","title":"Messages","text":"<p>The query and reply sent by a DNS server follow a similar pattern</p> <ol> <li>Header Section (12 bits)<ul> <li>16 bit identifier identifies the query</li> <li>Flags such as, 1 bit query(0)/reply(0), 1 bit auth flag, 1 bit recursion-desired flag, 1 bit recursion-available flag</li> </ul> </li> <li>Question section<ul> <li>Name field which contains the name of the thing that is being queried.</li> <li>Type field which tells about the type of the question being asked about the name (A, MX, etc.).</li> </ul> </li> <li>Answer section<ul> <li>Contains the resource records for the name that was queried</li> <li>May contain multiple rr's</li> </ul> </li> <li>Authority section<ul> <li>Contains records of authoritative servers</li> </ul> </li> <li>Additional section<ul> <li>Additional info such as CNAME's of email/hostname aliases.</li> </ul> </li> </ol> <p>![[Pasted image 20240826223758.png]]</p> <p>To illustrate the structure of a DNS query and response, consider a request to resolve the domain name\u00a0<code>example.com</code>.\u00a0Table below\u00a0shows the interpretation of the bytes of the request. (Note that the exact structure of the UDP datagram consists of just the bytes shown, concatenated in order:\u00a0<code>123401000001...</code>) The header starts with a 16-bit randomly chosen identifier denoted as XID (<code>1234</code>\u00a0in our example), followed by a 16-bit value that serves as a bit mask. The structure of the bit mask is shown in\u00a0Table 4.8. The rest of the header after the bit-mask indicates how many entries are in each of the other fields, each as a 16-bit value.</p> <p>![[Pasted image 20240828085815.png]]</p> <p>Table 4.8\u00a0illustrates the structure of the 16-bit flag field that follows the XID field of a DNS header. In the message shown in\u00a0Table 4.7, the only bit set is the\u00a0<code>Recursion\u00a0Desired</code>\u00a0(<code>RD</code>) bit. The\u00a0<code>Opcode</code>\u00a0field indicates that this is a standard query (<code>SQUERY\u00a0=\u00a00000</code>). In the response shown in\u00a0Table 4.9, the flag value is\u00a0<code>0x8180</code>, which means that the Query Response (<code>QR</code>) bit has been set to indicate the message is a response, as well as the\u00a0<code>Recursion\u00a0Available</code>\u00a0(<code>RA</code>) bit. The\u00a0<code>RCODE</code>\u00a0field is used to indicate if an error occurs, and all 0 bits there indicates there was no error processing the query. Information on the other fields is available in RFC 1035.</p> <p>![[Pasted image 20240828085910.png]]</p> <p>Table 4.9\u00a0shows the response for the query from\u00a0Table 4.7. In the response, the\u00a0<code>header</code>\u00a0is almost identical to that of the request. The randomly chosen identifier\u00a0<code>XID</code>\u00a0should match the original request; if the resolver has sent multiple requests, the\u00a0<code>XID</code>\u00a0field allows the resolver to determine which request is being answered. The bit mask has been modified to denote that this message is a response and the recursive resolution strategy is available. The\u00a0<code>header</code>\u00a0also indicates that a single answer has been provided. The\u00a0<code>question</code>\u00a0field is identical to the original request.</p> <p>![[Pasted image 20240828090348.png]]</p>"},{"location":"notes/Application%20Layer/#inserting-records-in-dns-db","title":"Inserting records in DNS DB","text":"<ol> <li>Register your domain through the registrar (requires a small fee to be paid). Registrar ensure uniqueness.</li> <li>Provide IP addresses of 1st, 2nd, (so on) auth DNS servers. For each server there would be a Type A and Type NS record in the TLD servers.</li> <li>Make sure to have Type MX and A rr's entered in your auth DNS server.</li> </ol> <p>4.6. UDP Socket Programming: DNS \u2014 Computer Systems Fundamentals (jmu.edu)</p>"},{"location":"notes/Application%20Layer/#socket-programming","title":"Socket Programming","text":""},{"location":"notes/Computer%20Networks%20and%20the%20Internet/","title":"What is the Internet","text":""},{"location":"notes/Computer%20Networks%20and%20the%20Internet/#nuts-and-bolts-description","title":"Nuts and Bolts Description","text":"<p>The internet is a computer network that interconnects billions of computing devices throughout the world. On the internet, all of these devices are called hosts or end systems.</p> <p></p> <p>End systems are connected to each other by a network of communication links (coaxial, copper, optical, etc.) and packet switches. Different links can transmit data at different rates.</p> <p>Transmission rate of a link is measured in bits/second.</p> <p>When data is to be transferred, it isn't just sent as raw data; it's modified and merged with additional information required by both end systems.</p> <p>Sending data system =&gt; Data + Header bytes (packets)</p> <p>The receiving end system receives the packets and de-structures them to get the original data.</p> <p>How does this packet reach the receiver end system though? Something called a packet switch is used to forward the packet received and send it to the appropriate end system based on the headers present.</p> <p>The two most prominent types of packet switches are Routers and Link-Layer switches.</p> <p>Routers =&gt; Access networks (An access network is a type of network which physically connects an end system to the immediate router (also known as the \u201cedge router\u201d) on a path from the end system to any other distant end system.)</p> <p>Link Layer Switches =&gt; Network core (Part of a telecom system that connects users and the network)</p> <p>The sequence of communication links and switches that are traversed by a packet is known as a route or path.</p> <p>The internet provided to the End systems allows the transfer of data. The internet is provided through Internet Service Providers (ISPs).</p> <p>Essentially, each ISP in itself is a network of packet switches and communication links.</p> <p>Examples of some network access provided by ISPs are Cable modem/DSL &amp; mobile wireless access.</p> <p>Now there are multiple tiers of ISPs that have to be interconnected to provide internet access.</p> <ol> <li>Lower Tier</li> <li>National Tier</li> <li>International Upper Tier</li> </ol> <p>Each of these ISPs are managed and runs the IP Protocol and adheres to the standards that are set by some organizations.</p> <p>The IP protocol mentioned above isn't the only protocol, and it isn't only run by ISPs. End systems, switches, and other devices present on the internet also run the protocols.</p> <p>The two most important protocols on the internet are: 1. Transmission Control Protocol (TCP) 2. Internet Protocol (IP)</p> <p>These two protocols are collectively called TCP/IP.</p> <p>As for the standards mentioned, the Internet standards are developed by the Internet Engineering Task Force (IETF).</p> <p>The IETF standards documents are called Request for Comments (RFCs). RFCs define protocols such as TCP, IP, HTTP, etc. There are currently 7,000 RFCs.</p>"},{"location":"notes/Computer%20Networks%20and%20the%20Internet/#services-description","title":"Services Description","text":"<p>The previous section described the internet using its components. But we can also describe it as an infrastructure that provides services to applications.</p> <p>Traditional applications (email, web surfing, messaging, maps, etc.) are said to be distributed applications since they involve multiple end systems that exchange data with each other.</p> <p>The internet primarily runs on the end systems, and the packet switches help with the exchange of data among end systems.</p> <p>But how do these applications run on the end systems? To even make an application first, we need to write it using a language such as C, JAVA, etc. </p> <p>These programs can be run on end systems independently, but for these programs to transfer data and communicate, we need something called a socket interface, which is provided by the Internet.</p> <p>The socket interface specifies how a program on the end systems asks the Internet to deliver data to a specific destination.</p> <p>Again, this socket interface also has to follow a set of rules that the sending program must follow.</p>"},{"location":"notes/Computer%20Networks%20and%20the%20Internet/#what-is-a-protocol","title":"What is a Protocol?","text":"<p>A protocol is exactly what it says; all activity on the internet that involves two or more communicating remote entities is governed by a protocol.</p> <p>A simple example where a protocol is used is on the Web. When we first type the URL of a Web page into a web browser, the computer sends a request to the server. The server receives this and sends an OK for the connection. Following this, the computer then sends a GET request to the server to load the web page. At last, the server returns the web page to the computer.</p> <p>A protocol defines the format and the order of messages exchanged between two or more communicating entities, as well as the actions taken on the transmission and/or receipt of a message or other event.</p> <p></p>"},{"location":"notes/Ethernet%20Cables/","title":"Ethernet Cables","text":"<p>These cables are the reason we can do things on the internet.</p> <p>A standard Ethernet cable consists of 4 twisted pairs of wires within an outer covering. But why twisted?</p> <ul> <li>In the real world, there is a lot of Electromagnetic Interference (EMI) that can disrupt the signals traveling through these wires.</li> <li>Another source of interference is the neighboring wires themselves. If the wires were laid out in parallel, there would be signal interference between them, known as crosstalk.</li> </ul> <p>These types of cables are called Unshielded Twisted Pair (UTP) cables. There are also Shielded Twisted Pair (STP) cables, where the twisted pairs are shielded with an extra coating to provide additional protection.</p> <p>Modern Ethernet cables typically contain 4 pairs of twisted wires, all color-coded\u2014specifically orange, blue, green, and brown. These pairs of wires transmit and receive signals, enabling communication.</p> <p>This type of Ethernet is called Cat5e Ethernet cable, designed for 1000Base-T networks, which refers to twisted pairs of wires capable of transmitting data at 1000 Mbps (1 Gbps).</p> <p>Cat5e refers to the specific category of twisted pair cables used in Ethernet.</p>"},{"location":"notes/Ethernet%20Cables/#internals-of-ethernet-cable","title":"Internals of Ethernet Cable","text":"<p>Before the 8-wire cables, Ethernet used 4-wire cables, such as in the 10Base-T and 100Base-TX standards.</p> <p>The 10Base-T Ethernet cable consisted of just 2 pairs of twisted wires (or 4 wires total).</p> <p>One pair was designated for sending data, while the other was for receiving data. Data is transferred by fluctuating the voltage, representing binary data (1's and 0's), along with encoding/decoding techniques.</p> <p>However, the cables alone aren't sufficient. A connector on both ends of the cable, called an RJ-45, completes the circuit by providing metal pins. Each pin on the connector has a specific function, and the way the wires are attached to the pins determines the cable's behavior.</p>"},{"location":"notes/Ethernet%20Cables/#common-cable-configurations","title":"Common Cable Configurations","text":"<ol> <li> <p>Straight-Through Cable</p> <ul> <li>In this design, the wires are connected in the same sequence on both ends of the cable. For instance, if a wire is attached to pin 1 on one end, it will also be attached to pin 1 on the other end.</li> <li>This configuration is ideal for connecting two different types of devices (e.g., a computer to a switch).</li> <li>![[Pasted image 20240829172955.png]]</li> <li> <p>Crossover Cable</p> </li> <li> <p>In this design, the wires are crossed and connected to different pins on the opposite ends (following a specific pattern).</p> </li> <li>This configuration is useful when connecting two similar devices (e.g., computer to computer).</li> <li>![[Pasted image 20240829172943.png]]</li> </ul> </li> </ol> <p>In newer Ethernet cables, like the 1000Base-T, there are 8 wires, but only 4 of them are used for simultaneous data transmission and reception.</p> <p>These modern Ethernet cables also follow the same cable configurations as discussed above.</p> <p>There are also naming conventions for the wiring arrangements, known as T568A and T568B. By using a combination of these standards, we can create the desired cable configuration (straight-through or crossover), for example, using T568A on one end and T568B on the other for a crossover cable. ![[Pasted image 20240829173255.png]]</p> <p>Modern switches and Ethernet devices have a feature called Auto MDI-X, which allows them to automatically configure the pins, enabling the use of straight-through cables regardless of the devices being connected.</p>"},{"location":"notes/Hybrid-Cloud/","title":"Hybrid Cloud","text":"<p>On-premise data centers have been around for a long time, providing businesses with the ability to manage and control their own IT infrastructure. However, these centers can be quite expensive to maintain, which is why many organizations are increasingly opting to move to the cloud.</p> <p>The public cloud offers the same, and often more, features as traditional on-premise data centers, but at a lower cost and with greater flexibility. In recent years, there has been a shift in software development from building large, monolithic applications to creating smaller, more manageable applications known as microservices. Microservices make it easier to write, update, and deploy code. Each microservice operates within its own container, often managed by services like Kubernetes (K8s).</p> <p>While this approach has many benefits, such as scalability and ease of management, there are still challenges when it comes to security, speed, and compliance. This is where the concept of a hybrid cloud comes in. A hybrid cloud environment combines on-premise infrastructure with cloud resources, allowing organizations to take advantage of both.</p> <p>However, hybrid cloud setups come with their own set of disadvantages:</p> <ol> <li>Cost: Managing both on-premise and cloud environments can be more expensive.</li> <li>Learning Curve: Engineers familiar with on-premise systems need to learn about cloud technologies.</li> <li>Feature Discrepancy: Certain features available in the cloud might not be available on-premise, and vice versa.</li> </ol> <p>To address these challenges, Dell and VMware have collaborated to create servers with cloud-like features built in. VMware Cloud Foundation is integrated into Dell servers, enabling organizations to perform both on-premise and cloud operations seamlessly. This same cloud foundation is also integrated into various cloud services, simplifying management and operations across environments.</p> <p>Software-Defined Data Centers (SDDC) further enhance this by allowing automation of various tasks. SDDCs bring cloud-like features to on-premise servers, making it easier to manage resources and create containers using Kubernetes.</p>"},{"location":"notes/IP%20addresses/","title":"IP addresses","text":"<p>When IP addresses were first created, they looked like this: <code>255.255.255.255</code>. This is called an IPv4 address, which consists of 4 octets separated by 3 dots. Each octet can range from 0 to 255.</p> <p>This IP address configuration allowed for over 4 billion possible addresses to be assigned to devices worldwide. However, due to inefficient management of these addresses, we eventually ran out of them. Let\u2019s look at how this happened.</p>"},{"location":"notes/IP%20addresses/#ip-address-classes","title":"IP Address Classes","text":"<p>IP addresses are classified into different classes, with each class having a specific range of addresses. The classes are A, B, C, D, and E.</p> Class Range Subnet Mask No. of Networks A 0 - 127 255.0.0.0 128 B 128 - 191 255.255.0.0 16,384 C 192 - 223 255.255.255.0 2,097,152 D 224 - 239 N/A N/A E 240 - 255 N/A N/A <p>The subnet mask defines which part of the IP address is the network portion and which part is the host portion. The octets that match <code>255</code> in the subnet mask are fixed and define the network, while the octets that don\u2019t match <code>255</code> can vary and define individual hosts within that network.</p> <p>Class A addresses, which provide a large number of host addresses, are typically assigned to large organizations and government entities.</p> <p>When an IP address conforms to the class and subnet mask specifications, it is part of a Classful network. However, if we take an IP address and apply a different subnet mask than the default for its class, it belongs to a Classless network.</p> <p>For example, the IP address <code>9.0.0.0</code> with a subnet mask of <code>255.0.0.0</code> is in a classful network. But if we take an address from this network, say <code>9.1.4.0</code>, and assign it a subnet mask of <code>255.255.255.0</code>, it becomes part of a classless network.</p> <p>The subnet mask also tells us how many networks and how many hosts per network we can have. Class C provides the most networks with fewer hosts per network compared to Classes A and B.</p> <p>Class D is used for multicasting, while Class E is reserved for experimental purposes and is not commonly used.</p> <p>The range <code>127.0.0.0</code> is reserved as a loopback address, which is used for testing and diagnostics on a local machine. The most common loopback address is <code>127.0.0.1</code>, often referred to as \"localhost.\" This means we have about 16 million addresses dedicated to testing purposes.</p>"},{"location":"notes/IP%20addresses/#private-ip-addresses","title":"Private IP Addresses","text":"<p>As the available IPv4 addresses began to run out, RFC 1918 was introduced to help mitigate the issue.</p> <p>The solution was to designate certain ranges from the existing classes (A, B, and C) as private addresses. These private IP address ranges are:</p> <ul> <li>Class A: 10.0.0.0 - 10.255.255.255 (Subnet Mask: 255.0.0.0)</li> <li>Class B: 172.16.0.0 - 172.31.255.255 (Subnet Mask: 255.240.0.0)</li> <li>Class C: 192.168.0.0 - 192.168.255.255 (Subnet Mask: 255.255.0.0)</li> </ul> <p>Private IP addresses are used within local networks and are not routable on the public internet. This means that multiple devices across different networks can have the same private IP addresses without causing conflicts.</p> <p>However, devices within a local network using private IP addresses need a way to communicate with the internet. This is achieved through Network Address Translation (NAT), a process performed by your router.</p> <p>When a device with a private IP wants to communicate with the internet, the router uses a public IP address provided by your ISP. NAT translates the private IP to the public IP, allowing the device to communicate externally. When a response is received, the router uses NAT to direct the response to the correct device within the local network.</p> <p>Even with NAT, the exhaustion of IPv4 addresses remained a problem, leading to the development and adoption of IPv6, which provides a much larger address space.</p>"},{"location":"notes/Network%20Architecture/","title":"Network Architecture","text":"<p>How exactly are networks designed in the real world? What are the design criteria's they follow? How are failure points avoided? These answers are all answered by the network architecture we will discuss.</p> <p>A bad system design consists of a single point of failure, where one switch connects another switch which in the end connects to multiple devices. Failure of the first switch, could lead to failure of the devices indirectly connected to it. This can be avoided by simply following some kind of architecture rules.</p> <p></p> <p>This is formally called as Daisy Chaining of Switches</p>"},{"location":"notes/Network%20Architecture/#2-tier-architecture","title":"2 Tier Architecture","text":"<p>As we saw above, failure in one device could lead to failure in other devices too. To prevent this (not completely), we make use of the 2 Tier architecture.</p> <p>What are the two tiers? 1. Access layer 2. Distribution layer</p> <p>Here instead of one switch connecting to other, we introduce a Multi layer switch. Now unlike normal switches, the multi layer switch works in L3 layer, i.e. it deals with IP-addresses. It's almost similar to routers, but routers can't send out packets like a switch.</p> <p>Using this new multi layer switch, our smaller connections which include a switch and other devices connected to it (forms the access layer) are connected to the multi layer switch and this connects to the router (the switch and router form the distribution layer).</p> <p>Now this is significantly better than what we had before, but we still have a single point of failure.</p> <p></p>"},{"location":"notes/Network%20Architecture/#3-tier-architecture","title":"3 Tier Architecture","text":"<p>Now someone decided to add another complicated layer of single point of failure, Great. This layer is almost similar to 2 tier, but this one contains 3 layers.</p> <p>What are the layers? 1. Access Layer 2. Distribution Layer 3. Core Layer</p> <p>The access layer and the distribution layer are still the same, but the distribution layer, or the multi layer switches of the dist. layer are connected to more multi layer switches, specifically 2. These are the backbones of the architecture. These new switches are then connected to two routers.</p> <p>This architecture is used by large enterprises as they are quite expensive compared to our previous architectures.</p> <p></p>"},{"location":"notes/Network%20Architecture/#collapsed-2-tier-architecture","title":"Collapsed 2 Tier Architecture","text":"<p>Now smaller enterprises wanted something similar to the 3 tier arch. but something more inexpensive. The collapsed 2 tier architecture solves that. I</p> <p>t's almost similar to the normal 2 tier architecture but instead of one multi layer switch in the distribution layer, it contains two. This reduces the single point of failure, which is why it's also more ideal than the normal 2 tier architecture.</p> <p></p>"},{"location":"notes/Network%20Models/","title":"Network Models","text":"<p>The need of network models arose when different networks consisting of different machines could not communicate with each other.</p> <p>For example, in the 1960's, many companies developed their own networks based on the ideology of the ARPANET, but these networks could not communicate with each other as they were proprietary.</p> <p>With this need of some kind of standard model, came two models, TCP/IP and the OSI network models.</p>"},{"location":"notes/Network%20Models/#tcpip-vs-osi","title":"TCP/IP vs OSI","text":""},{"location":"notes/Network%20Models/#tcpip","title":"TCP/IP","text":"<p>The Transmission control protocol/Internet protocol (aka TCP/IP) has a layered architecture consisting of 4 layers.</p> <ol> <li>Application</li> <li>Transport</li> <li>Network</li> <li>Physical</li> </ol> <p>At times, Physical layer is divided into two layers, Physical and Data Link layer</p>"},{"location":"notes/Network%20Models/#osi","title":"OSI","text":"<p>Open system interconnect (aka OSI). This model is mostly a conceptual model used in network comms by network engineers.</p> <p>It has a 7 layers architecture where most of the layers are similar to the TCP/IP</p> <ol> <li>Application</li> <li>Presentation</li> <li>Session</li> <li>Transport</li> <li>Network</li> <li>Data link</li> <li>Physical</li> </ol> <p>The Presentation and Session layers are stuffed as one to form the application layer in the TCP/IP model.</p> <p></p>"},{"location":"notes/Network%20Models/#acronyms","title":"Acronyms","text":"<ul> <li>All People Seem To Need Data Processing</li> <li>Please Do Not Throw Sausage Pizza Away</li> </ul> <p>The process of taking data and merging it with important related info is called encapsulation.</p>"},{"location":"notes/Network%20Models/#data-traversal-through-model-layers","title":"Data traversal through model layers","text":"<p>When the user wants to send data to another device, the data has to go down all the layers and get enclosed in a figurative envelope and then go up through all the layers and get opened in each layers, one by one.</p> <p>Lets understand this in a bit detail.</p> <p>Starting from the senders side, say we want to access a website. We will need to send a request to that website. To send this request we use the HTTPS protocol.</p>"},{"location":"notes/Network%20Models/#application-layer","title":"Application Layer","text":"<p>First this request will go through the application layer. It goes in the form of data which contains the info about the request and the protocol used.</p>"},{"location":"notes/Network%20Models/#transport-layer","title":"Transport Layer","text":"<p>Now this data goes down to the transport layer. Here in the transport layer, there are two protocols we mainly use, TCP (Transmission control protocol) and UDP (user datagram protocol)</p> <p>High-level difference between the two protocols</p> TCP UDP More reliable Fast <p>In this layer (L4 or transport), along with the data, another header is attached which contains info about the protocol.</p> <p>There is info like the destination port (ex: 1234) and the source port (which can be 443 -&gt; port number for HTTPS traffic).</p> <p>This data is called segments.</p>"},{"location":"notes/Network%20Models/#network-layer","title":"Network layer","text":"<p>This segment of data is now passed down to the network layer where we further encapsulate it with headers. This header contains info about the IP addresses of the source and destination.</p> <p>This header is important for the router (the router can only understand IP addresses i.e. L3 addr.) to get directions.</p> <p>The data in this layers is also referred to as packets.</p>"},{"location":"notes/Network%20Models/#data-link-layer","title":"Data Link layer","text":"<p>The packet is now sent down to the data link layer. Here, instead of just adding a header, a trailer is also added. </p> <p>The header here contains the mac addr. of the source and destination. This is needed to give directions to the switch (the switch only understands MAC address i.e. L2 addr.)</p> <p>The data in this layer is also called frames</p>"},{"location":"notes/Network%20Models/#physical-layer","title":"Physical layer","text":"<p>Finally after all the encapsulation, we receive the frames from data link layer, and now we can send the frames to the website we wanted access.</p>"},{"location":"notes/Network%20Models/#receivers-end","title":"Receivers End","text":"<p>In the receivers side, the data isn't just taken as a frame, the frame must go through the procedure of un-encapsulation so that the routers, switches can read the address of the destination.</p> <p>One by one, up the layer, each header/trailer is removed until we reach the application layer and finally receive the data.</p>"},{"location":"notes/Routers/","title":"Routers","text":"<p>Switches are good in helping connect devices that are present in a given network range (For ex - 10.1.1.0 - 10.1.1.255), but what if we want to send frames to a device which is in another network range?</p> <p>You'd probably think that we can do this task simply by connecting two switches that belong to two different network ranges. But this is wrong. Let us see why.</p>"},{"location":"notes/Routers/#same-network-range-devices","title":"Same network range devices","text":"<p>Initially, the source needs to learn the L2 address (MAC address) of the destination, so it sends a broadcast packet to the switch, since this is a broadcast packet, all the devices connected receive this packet. The device which was actually meant to receive this, accepts the packet and resends the confirmation packet along with its L2 address (MAC address).</p> <p>Note that this broadcast packet contains L1 and L2 data. The L2 contains something called ARP Packet Source which contains the L3 addresses of the source and destination. </p> <p>This broadcast packet is formally called the ARP packet.</p> <p></p>"},{"location":"notes/Routers/#different-network-range-devices","title":"Different network range devices","text":"<p>Now this all works when the devices are in the same network range. Once we try to send frames to a device in another network range, the switch goes haywire.</p> <p>Lets we try to connect a 10.1.1.2 device to a random device in the 23.227.38.0 - 23.227.38.255 range.</p> <p>The 1.2 devices gives up immediately instead of trying to find out the MAC address of the destination device (belonging to the other network range).</p> <p>If we take a closer loop at the ARP packet, the ARP Packet source which should contain the source and destination IP addr. actually contains the source and the gateway IP address. (here gateway is 10.1.1.1)</p> <p></p> <p>Example of a device having which has a gateway address set</p> <p></p> <p>What is the gateway IP address? This address is what is actually used by a router to allow us to connect with devices out of our network range.</p> <p>Which is why we require routers to connect to devices out of our network range.</p>"},{"location":"notes/Routers/#formal-definition-of-routers","title":"Formal definition of routers","text":"<p>Routers are a medium to connect different networks to allow transmission of data between devices that belong to different network (network ranges).</p>"},{"location":"notes/Routers/#what-happens-when-routers-get-a-arp-packet","title":"What happens when routers get a ARP packet?","text":"<p>Recall how the 10.1.1.2 sends an ARP packet to find out the MAC address of a device it wants to connect in 23.227.38.0 - 23.227.38.255 range.</p> <p>Now that the router has received this ARP packet, it further will send another ARP packet as the router itself doesn't have the MAC address of the destination device. Here it sends it the ARP packet to a switch which falls in the network range of the destination device.</p> <p>Now once this ARP packet reaches the switch, the switch then again sends an ARP packet to all the devices connected to it. Once it the destination device receives the ARP packet, it sends back a confirmation packet back to through the same route towards the source.</p> <p>Once the source receives this, it keeps a record of it for future communications.</p>"},{"location":"notes/Subnet%20Mask/","title":"Subnet Mask","text":""},{"location":"notes/Subnet%20Mask/#importance-of-the-subnet-mask","title":"Importance of the Subnet Mask","text":"<p>A subnet mask is important because it defines how many networks and hosts can exist within a given network. By converting an IP address and its subnet mask into binary, we can determine the network bits and host bits.</p> <ul> <li>Network Bits: These bits define the network portion of the IP address and generally remain constant.</li> <li>Host Bits: These bits identify individual hosts within the network and are used to assign addresses to devices.</li> </ul> <p>Number of hosts = 2 ^ (number of host bits) - 2</p> <p>The subtraction of 2 accounts for the network address and the broadcast address.</p> <p>Classless Inter-Domain Routing (CIDR): CIDR extends the number of available IP addresses and provides a compact representation of an IP address and its associated network mask.</p>"},{"location":"notes/Subnet%20Mask/#subnetting-based-on-number-of-networks","title":"Subnetting Based on Number of Networks","text":"<p>If you need to create more networks, you can increase the number of network bits by borrowing bits from the host portion. This process is known as subnetting.</p> <p>To determine how many bits to borrow:</p> <ol> <li>Use powers of 2:<ul> <li><code>128 &lt;- 64 &lt;- 32 &lt;- 16 &lt;- 8 &lt;- 4 &lt;- 2 &lt;- 1</code></li> <li>By doubling these values: <code>256 &lt;- 128 &lt;- 64 &lt;- 32 &lt;- 16 &lt;- 8 &lt;- 4 &lt;- 2</code></li> </ul> </li> <li>For example, if you need 4 additional networks, you need to borrow 2 bits (from 2 -&gt; 4 &amp; also 2^2 = 4).</li> </ol> <p>In CIDR notation, borrowing 2 bits changes the subnet mask from <code>/24</code> to <code>/26</code>:</p> <ul> <li>Original subnet mask: <code>11111111.11111111.11111111.00000000</code> -&gt; <code>/24</code></li> <li>After borrowing 2 bits: <code>11111111.11111111.11111111.11000000</code> -&gt; <code>/26</code></li> </ul> <p>To determine the range of each subnet, find the increment, which is the value of the last network bit used. For a <code>/26</code> subnet mask, the increment is 64.</p> <p>Example subnets:</p> <ol> <li><code>192.168.1.0 - 192.168.1.63</code></li> <li><code>192.168.1.64 - 192.168.1.127</code></li> <li><code>192.168.1.128 - 192.168.1.191</code></li> <li><code>192.168.1.192 - 192.168.1.255</code></li> </ol> <p>To summarise, 1. Calculate the number of host bits required. 2. Borrow the required number of host bits. 3. Find the increment. 4. Create your subnets using the increment.</p>"},{"location":"notes/Subnet%20Mask/#subnetting-based-on-number-of-hosts","title":"Subnetting Based on Number of Hosts","text":"<p>If you need to divide the network based on the number of hosts, you need to keep the host bits and save them accordingly.</p> <p>To determine how many bits to save:</p> <ol> <li>Use powers of 2 to find the number of bits needed:<ul> <li><code>128 &lt;- 64 &lt;- 32 &lt;- 16 &lt;- 8 &lt;- 4 &lt;- 2 &lt;- 1</code></li> <li>By doubling these values: `256 &lt;- 128 &lt;- 64 &lt;- 32 &lt;- 16 &lt;- 8 &lt;- 4 &lt;- 2</li> <li>For 40 hosts, you need 6 bits (from 2 -&gt; 64 &amp; also 2^6 = 64).</li> </ul> </li> <li>In CIDR notation,<ul> <li>Original subnet mask: <code>11111111.11111111.11111111.00000000</code> -&gt; <code>/24</code></li> <li>After saving bits: <code>11111111.11111111.11111111.11000000</code> -&gt; <code>/26</code></li> </ul> </li> </ol> <p>To determine the range of each subnet, use the increment, which is the value of the last network bit used. For a <code>/26</code> subnet mask, the increment is 64.</p> <p>Example subnets:</p> <ol> <li><code>192.168.1.0 - 192.168.1.63</code></li> <li><code>192.168.1.64 - 192.168.1.127</code></li> <li><code>192.168.1.128 - 192.168.1.191</code></li> <li><code>192.168.1.192 - 192.168.1.255</code></li> </ol> <p>So we would provide the network info to our network admin as such, 1. <code>192.168.1.0 /26</code> 2. <code>192.168.1.64 /26</code> 3. <code>192.168.1.128 /26</code></p> <p>To summarize, 1. Calculate the number of host bits required. 2. Save the required number of host bits. 3. Find the increment. 4. Create your subnets using the increment.</p>"},{"location":"notes/Subnet%20Mask/#reverse-subnetting","title":"Reverse Subnetting","text":"<p>Using reverse subnetting we can find, 1. Network address 2. Broadcast Address 3. Network Range</p> <p>Given, - IPv4 addr: <code>10.200.56.120</code> - Subnet Mask: <code>255.255.254.0</code> - Default Gateway: <code>10.200.56.1</code></p> <p>First lets convert out subnet mask into binary, <code>11111111.11111111.11111110.0</code>, Hence the CIDR notation will be <code>/23</code>.</p> <p>The last network bit here will help us find our increment, which in this case is 2.</p> <p>Now our network starting address will look something like this, <code>10.200.0.0</code></p> <p>Our overall network ranges will look something like this 1. <code>10.200.0.0 - 10.200.1.255</code> 2. <code>10.200.2.0 - 10.200.3.255</code> 3. <code>10.200.4.0 - 10.200.5.255</code> and so on...</p> <p>So Our given IPv4 address has these features, 1. Network Range: <code>10.200.56.0 - 10.200.57.255</code> 2. Network address: <code>10.200.56.0</code> 3. Broadcast Address: <code>10.200.57.255</code></p>"},{"location":"notes/Subnet%20Mask/#other-way-to-reverse","title":"Other way to reverse","text":""},{"location":"notes/Subnet%20Mask/#given","title":"Given:","text":"<ul> <li>IPv4 Address: <code>10.200.56.120</code></li> <li>Subnet Mask: <code>255.255.254.0</code> (which corresponds to <code>/23</code> in CIDR notation)</li> <li>Default Gateway: <code>10.200.56.1</code></li> </ul>"},{"location":"notes/Subnet%20Mask/#step-by-step-explanation","title":"Step-by-Step Explanation:","text":"<ol> <li>Subnet Mask in Binary:</li> <li><code>255.255.254.0</code> in binary is <code>11111111.11111111.11111110.00000000</code>.</li> <li> <p>CIDR notation is <code>/23</code>, indicating that the first 23 bits are used for the network, and the remaining 9 bits are for hosts.</p> </li> <li> <p>Network Address Calculation:</p> </li> <li>The network address is found by ANDing the IP address with the subnet mask.</li> <li><code>10.200.56.120</code> in binary: <code>00001010.11001000.00111000.01111000</code></li> <li>Subnet mask: <code>11111111.11111111.11111110.00000000</code></li> <li>Network Address (AND operation):      <code>00001010.11001000.00111000.01111000      AND      11111111.11111111.11111110.00000000      -----------------------------------      00001010.11001000.00111000.00000000</code></li> <li> <p>The network address is <code>10.200.56.0</code>.</p> </li> <li> <p>Broadcast Address Calculation:</p> </li> <li>The broadcast address is found by setting all the host bits (the remaining bits after the network bits) to <code>1</code>.</li> <li>Network address: <code>00001010.11001000.00111000.00000000</code></li> <li>Broadcast Address:      <code>00001010.11001000.00111001.11111111</code></li> <li> <p>The broadcast address is <code>10.200.57.255</code>.</p> </li> <li> <p>Network Range:</p> </li> <li>The range of IP addresses in this subnet goes from the network address to the broadcast address.</li> <li>Network Range: <code>10.200.56.0</code> to <code>10.200.57.255</code></li> </ol>"},{"location":"notes/Subnet%20Mask/#summary-of-findings","title":"Summary of Findings:","text":"<ul> <li>Network Address: <code>10.200.56.0</code></li> <li>Broadcast Address: <code>10.200.57.255</code></li> <li>Network Range: <code>10.200.56.0</code> to <code>10.200.57.255</code></li> </ul>"},{"location":"notes/Subnetting%20%28GPT%20notes%29/","title":"Subnetting in IP Networks","text":""},{"location":"notes/Subnetting%20%28GPT%20notes%29/#overview","title":"Overview","text":"<p>Subnetting is a technique used in IP networking to divide a larger network into smaller, more manageable sub-networks (subnets). This allows for better organization, improved security, and efficient use of IP addresses. IP addresses are divided into classes: A, B, and C. Each class has a default subnet mask and a different number of networks and hosts.</p>"},{"location":"notes/Subnetting%20%28GPT%20notes%29/#ip-address-classes","title":"IP Address Classes","text":""},{"location":"notes/Subnetting%20%28GPT%20notes%29/#class-a","title":"Class A","text":"<ul> <li>Range: 1.0.0.0 to 126.0.0.0</li> <li>Default Subnet Mask: 255.0.0.0 (/8)</li> <li>Number of Networks: 128 (2^7, minus 2 reserved addresses)</li> <li>Hosts per Network: 16,777,214 (2^24 - 2)</li> </ul>"},{"location":"notes/Subnetting%20%28GPT%20notes%29/#class-b","title":"Class B","text":"<ul> <li>Range: 128.0.0.0 to 191.255.0.0</li> <li>Default Subnet Mask: 255.255.0.0 (/16)</li> <li>Number of Networks: 16,384 (2^14)</li> <li>Hosts per Network: 65,534 (2^16 - 2)</li> </ul>"},{"location":"notes/Subnetting%20%28GPT%20notes%29/#class-c","title":"Class C","text":"<ul> <li>Range: 192.0.0.0 to 223.255.255.0</li> <li>Default Subnet Mask: 255.255.255.0 (/24)</li> <li>Number of Networks: 2,097,152 (2^21)</li> <li>Hosts per Network: 254 (2^8 - 2)</li> </ul>"},{"location":"notes/Subnetting%20%28GPT%20notes%29/#subnetting-class-c-networks","title":"Subnetting Class C Networks","text":""},{"location":"notes/Subnetting%20%28GPT%20notes%29/#key-concepts","title":"Key Concepts","text":"<ol> <li>IP Address and Subnet Mask:</li> <li>An IP address consists of two parts: the network portion and the host portion.</li> <li>The subnet mask determines which part of the IP address is the network portion and which part is the host portion.</li> <li> <p>For a Class C network, the default subnet mask is 255.255.255.0 or /24 in CIDR notation.</p> </li> <li> <p>CIDR Notation:</p> </li> <li>Classless Inter-Domain Routing (CIDR) notation is a shorthand for denoting the subnet mask.</li> <li> <p>/24 means that the first 24 bits of the IP address are the network portion, leaving 8 bits for hosts.</p> </li> <li> <p>Subnetting:</p> </li> <li>Subnetting involves borrowing bits from the host portion to create additional network bits, thus creating more subnets.</li> <li> <p>For example, changing from /24 to /25 (borrowing 1 bit) doubles the number of subnets but halves the number of hosts per subnet.</p> </li> <li> <p>Number of Subnets and Hosts:</p> </li> <li>The number of subnets created can be calculated as 2^n, where n is the number of bits borrowed.</li> <li> <p>The number of hosts per subnet can be calculated as 2^(32 - subnet mask) - 2. The subtraction of 2 accounts for the network and broadcast addresses which cannot be assigned to hosts.</p> </li> <li> <p>Network ID and Broadcast Address:</p> </li> <li>The network ID is the first address in a subnet, used to identify the subnet.</li> <li>The broadcast address is the last address in a subnet, used to send data to all hosts in the subnet.</li> <li>Usable IP addresses are those between the network ID and the broadcast address.</li> </ol>"},{"location":"notes/Subnetting%20%28GPT%20notes%29/#example","title":"Example","text":"<p>For a Class C network 192.168.1.0 with a subnet mask of 255.255.255.192 (/26):    - Number of subnets: 2^(26-24) = 4 subnets.    - Number of hosts per subnet: 2^(32-26) - 2 = 62 hosts.</p> <p>The four subnets will be: 1. 192.168.1.0/26    - Network ID: 192.168.1.0    - Broadcast Address: 192.168.1.63    - Usable IP Range: 192.168.1.1 - 192.168.1.62</p> <ol> <li>192.168.1.64/26</li> <li>Network ID: 192.168.1.64</li> <li>Broadcast Address: 192.168.1.127</li> <li> <p>Usable IP Range: 192.168.1.65 - 192.168.1.126</p> </li> <li> <p>192.168.1.128/26</p> </li> <li>Network ID: 192.168.1.128</li> <li>Broadcast Address: 192.168.1.191</li> <li> <p>Usable IP Range: 192.168.1.129 - 192.168.1.190</p> </li> <li> <p>192.168.1.192/26</p> </li> <li>Network ID: 192.168.1.192</li> <li>Broadcast Address: 192.168.1.255</li> <li>Usable IP Range: 192.168.1.193 - 192.168.1.254</li> </ol>"},{"location":"notes/Subnetting%20%28GPT%20notes%29/#detailed-calculation","title":"Detailed Calculation:","text":"<ol> <li>Subnet Mask and CIDR Notation:</li> <li>The subnet mask 255.255.255.192 corresponds to /26 in CIDR notation.</li> <li> <p>This means that the first 26 bits are for the network, and the remaining 6 bits are for hosts.</p> </li> <li> <p>Number of Subnets:</p> </li> <li>We are borrowing 2 bits (26 - 24) from the host portion of the default Class C subnet mask (255.255.255.0).</li> <li> <p>Number of subnets = 2^2 = 4 subnets.</p> </li> <li> <p>Number of Hosts per Subnet:</p> </li> <li>Number of hosts per subnet = 2^(32 - 26) - 2 = 2^6 - 2 = 64 - 2 = 62 hosts.</li> <li> <p>The subtraction of 2 accounts for the network address and the broadcast address, which cannot be assigned to hosts.</p> </li> <li> <p>Subnet Increment:</p> </li> <li>Subnet increment = 256 / number of subnets = 256 / 4 = 64.</li> <li>This means each subnet increases by 64 addresses.</li> </ol>"},{"location":"notes/Subnetting%20%28GPT%20notes%29/#calculation-of-each-subnet","title":"Calculation of Each Subnet:","text":""},{"location":"notes/Subnetting%20%28GPT%20notes%29/#subnet-1-1921681026","title":"Subnet 1: 192.168.1.0/26","text":"<ul> <li>Network ID: The first address in the subnet range is 192.168.1.0.</li> <li>Broadcast Address: The last address in the subnet range is 192.168.1.63 (192.168.1.0 + 63).</li> <li>Usable IP Range: The addresses between the network ID and the broadcast address are 192.168.1.1 to 192.168.1.62.</li> </ul>"},{"location":"notes/Subnetting%20%28GPT%20notes%29/#subnet-2-19216816426","title":"Subnet 2: 192.168.1.64/26","text":"<ul> <li>Network ID: The next subnet starts at 192.168.1.64 (192.168.1.0 + 64).</li> <li>Broadcast Address: The last address in this subnet is 192.168.1.127 (192.168.1.64 + 63).</li> <li>Usable IP Range: The addresses between the network ID and the broadcast address are 192.168.1.65 to 192.168.1.126.</li> </ul>"},{"location":"notes/Subnetting%20%28GPT%20notes%29/#subnet-3-192168112826","title":"Subnet 3: 192.168.1.128/26","text":"<ul> <li>Network ID: The next subnet starts at 192.168.1.128 (192.168.1.64 + 64).</li> <li>Broadcast Address: The last address in this subnet is 192.168.1.191 (192.168.1.128 + 63).</li> <li>Usable IP Range: The addresses between the network ID and the broadcast address are 192.168.1.129 to 192.168.1.190.</li> </ul>"},{"location":"notes/Subnetting%20%28GPT%20notes%29/#subnet-4-192168119226","title":"Subnet 4: 192.168.1.192/26","text":"<ul> <li>Network ID: The next subnet starts at 192.168.1.192 (192.168.1.128 + 64).</li> <li>Broadcast Address: The last address in this subnet is 192.168.1.255 (192.168.1.192 + 63).</li> <li>Usable IP Range: The addresses between the network ID and the broadcast address are 192.168.1.193 to 192.168.1.254.</li> </ul>"},{"location":"notes/Subnetting%20%28GPT%20notes%29/#why-is-it-256","title":"Why is it 256?","text":"<ol> <li>Total Number of Addresses in One Octet:</li> <li> <p>The fourth octet can have values from 0 to 255, giving a total of 256 values.</p> </li> <li> <p>Number of Subnets:</p> </li> <li>The number of subnets is determined by the number of bits borrowed from the host portion of the address.</li> <li> <p>For example, if you borrow 2 bits for subnetting in a Class C network, you get (2^2 = 4) subnets.</p> </li> <li> <p>Subnet Increment:</p> </li> <li>The subnet increment is calculated as:       [      \\text{Subnet Increment} = \\frac{256}{\\text{Number of Subnets}}      ]</li> <li>In this case, with 4 subnets, the calculation is:      [      \\text{Subnet Increment} = \\frac{256}{4} = 64      ]</li> </ol> <p>By following these steps, you can divide a Class C network into multiple subnets and determine the network ID, broadcast address, and usable IP range for each subnet.</p>"},{"location":"notes/Switches/","title":"Switches","text":"<p>A switch is a device that allows multiple users to connect at once to allow sharing of data through the use of ports.</p> <p>It supports, - Unicast - Multicast - Broadcast</p> <p>The switch works in the layer 2 of the OSI model of network, where it uses the MAC address to allow data transfer between devices.</p>"},{"location":"notes/Switches/#switch-vs-hub","title":"Switch v/s Hub","text":"<p>In switches, we know that the message is only sent to the respective receiver, this wasn't always the case. Earlier Hubs were used, which not only sent the message to the appropriate receiver, but sent the message to every device connected to its ports.</p> <p>This was a major disadvantage. The main reason for this is that the Hub only operated in layer 1 of the OSI model, meaning it didn't have access to the MAC addresses of the devices connected to it. (MAC addresses belong to layer 2).</p>"},{"location":"notes/Switches/#cam-tables","title":"CAM Tables","text":"<p>Content Addressable Memory table, or commonly known as CAM tables, are specially type of memory tables used by switches.</p> <p>This table stores the MAC addresses of the devices connected to its ports. This makes it easy for the switch to transfer messages only to the devices in question.</p> <p>The switches don't automatically have this table generated, the table is built by recording the source address and inbound port of all frames.\u00a0As frames arrive on switch ports, the source MAC addresses are learned and recorded in the CAM table.</p> <p>When a frame arrives at the switch with a destination MAC address of an entry in the CAM table, the frame is forwarded out through only the port that is associated with that specific MAC address. The information a switch uses to perform a lookup in a CAM table is called a key.</p> <p>An example of a network which uses a Switch</p> <p></p> <p>Example of the CAM Table or MAC Forward Table</p> <p></p>"},{"location":"notes/Transport%20layer/","title":"Transport layer","text":"<p>Transport Layer protocols provide a logical communication between application processes running b/w hosts. This logical communication allows processes to send messages to each other.</p> <p>The TL protocols are implemented on end systems. When the process wants to send message to another process, the message will pass through its application layer to its transport layer. Here the transport layer will split this message into chunks and attach a transport layer header, these chunks are called segments.</p> <p>The segments are sent down to the network layer where they are encapsulated with the network layer header. (datagram)</p> <p>Transport layer provides logical communication between processes in end systems whereas network layer provides logical communication b/w hosts.</p> <p>Service provided an upper layer usually depends on a service provided by a lower layer.</p> <p>Transport layer packets are referred to as segments. Particularly, packets sent using TCP are segments and using UDP are datagrams.</p> <p>Since network layer packets are also datagrams, we refer to TCP/UDP packets as segments.</p> <p>Network layer has its own protocol, Internet Protocol. It's called a best effort delivery service protocol, i.e. it tries its best to deliver the packets but it doesn't guarantee the delivery of the packets. So we can call the IP a unreliable protocol.</p> <p>The IP is aided with the UDP/TCP to make it more reliable. TL protocols extend their help to aid IP to help with its delivery service.</p> <p>Although, IP aided with UDP is actually more unreliable compared to IP aided with TCP as TCP provides reliable data transfer and congestion control. </p> <p>Congestion control allows equal share of bandwidth to TCP connections. This protocol prevents one connection from swamping the links &amp; routers </p> <p>Extending host-to-host delivery to process-to-process is called transport layer multiplexing and demultiplexing.</p>"},{"location":"notes/Transport%20layer/#multiplexing-demultiplexing","title":"Multiplexing &amp; Demultiplexing","text":"<p>The host-to-host delivery service provided by the network layer extended to a process-to-process delivery service for applications running on hosts. This service is required by every computer running applications.</p> <p>A process can have one or more sockets at the same time, hence the sockets require a unique identifier which is the port number. But instead of sending the message directly to the socket at its port number, the msg is first sent to an intermediate port.</p> <p>At the receiving end, the transport layers receives the segments and examines it for the destination port number and sends the message accordingly. This is demultiplexing.</p> <p>The job of gathering data, port numbers (source and destination) &amp; attaching the transport layer header to the segments and then sending this to the network layer is called multiplexing ![[Pasted image 20240830100108.png]]</p> <p>Hence Multiplexing requires, 1. Unique identifier for ports 2. Each segment having special fields indicating the destination socket.</p> <p></p> <p>Port number is 16 bit number ranging from 0 to 65535. Well known ports range from 0 to 1023.</p>"},{"location":"notes/Transport%20layer/#connectionless-mux-and-demux","title":"Connectionless mux and demux","text":"<ul> <li>UDP is used this.</li> <li>During UDP socket programming, OS automatically assigns ports numbers to sockets or the application programmer can assign it their selves.</li> <li>If the programmer is implementing a well known port program, they must assign the socket the well known port itself.</li> <li>UDP socket is fully identified by a two tuple, dest. IP addr and dest. port number</li> <li>If two UDP segments have different source IP addr and/or port numbers but same dest. ip &amp; port number, then the two segments are directed to the same process via the same socket.</li> </ul> <p>Example</p> <p>Host A (UDP port 19157) wants to send to -&gt; Host B (UDP port 46428)</p> <ul> <li>A creates segment which includes =&gt; Dest. port, source port, and other values</li> <li>segment -&gt; n/w layer -&gt; encapsulated w/ n/w header -&gt; datagram</li> <li>A datagram sent to B. </li> <li>B transport layer receives and examines segment.</li> <li>Sends message to desired port (46428)</li> </ul>"},{"location":"notes/Transport%20layer/#connection-oriented-mux-and-demux","title":"Connection oriented mux and demux","text":"<ul> <li>TCP socket is identified by a four tuple, source IP, source Port, dest. IP, dest Port.</li> <li>Two TCP segments with different source IP and/or port numbers are directed to two different sockets.</li> <li>In a simple TCP implementation application, the server side has a \"welcome socket\" ready to receive connection requests. The TCP client sends a connection establishment request.</li> </ul> <p>Connection establishment request contains nothing but the dest. port number and some special connection establishment bit set in TCP header and source port number.</p>"},{"location":"notes/Transport%20layer/#port-security","title":"Port security","text":"<p>A process on the server usually waits for requests on an open port. Once the client finds this open port it can easily map out the process linked to it. </p> <p>This can be useful in finding which network applications are running on the host. But this can also lead to a security vulnerability, if the open port has a known security flaw, then the host is doomed for an attack.</p>"},{"location":"notes/Transport%20layer/#web-server-tcp","title":"Web server &amp; TCP","text":"<p>Earlier web servers created a new process which had its own socket for every new TCP connection made. But new high-performing web servers use only one connection. </p> <p>Servers create threads for each new connection with a new socket for each connection. So there could be at a given moment there could multiple sockets pointing to the same process.</p> <p>In a persistent connection, one socket is responsible for HTTP communication between client and server.</p> <p>In non-persistent connection, multiple sockets are created and closed for each request &amp; response between the client and server. This can create load on a busy server.</p>"},{"location":"notes/Transport%20layer/#connectionless-transport-udp","title":"Connectionless Transport: UDP","text":"<ul> <li>UDP is a connectionless protocol with little error checking and mux &amp; demux functions.</li> <li>UDP adds almost nothing to IP.</li> </ul> <p>We know,  - UDP takes the message from application process, attaches source &amp; dest port number for mux &amp; demuxing and other small fields. - This segment is encapsulated with the transport layer header and sent to the network layer. Then it's further encapsulated with the network header to form the IP datagram. This datagram is then sent to the destination. - As we see, there is no handshaking done between the source &amp; destination. Hence UDP is connectionless.</p> <p>And, - DNS is another application layer protocol that uses UDP as its underlying protocol. - The host side UDP makes its segment, passes it to the network layer to make the datagram and this is sent to the name server - If DNS application at the host side doesn't get any reply, it tries sending a query again &amp; if after repeated trying it doesn't get a reply, it informs the invoking application.</p> <p>Why UDP over TCP if it's unreliable? 1. Finer application layer control over when data is sent     - UDP quickly encapsulates the message w/ the headers and port information and sends it to the network layer.      - On the other hand TCP has congestion control &amp; does a three-way handshake. TCP keeps on sending a packet until it receives the ack. packet back from destination. 2. No connection establishment     - UDP just blasts away without any formal preliminaries. UDP doesn't introduce any delays.     - This is probably the reason why DNS using UDP. Even HTTP.     - Google Chrome browsers use QUIC, Quick UDP Internet Connection. Which uses UDP as its underlying transport protocol and implements reliability in an application layer protocol on top of UDP. 3. No connection state     - TCP maintains a connection for each request and response whereas UDP doesn't maintain any connection and doesn't track any parameters 4. Small packet header overhead     - UDP has only 8 bytes of header and TCP has 20 bytes of header.</p> <p>But the delays introduced by HTTP over TCP is necessary to download important documents.</p> <p></p> <ul> <li>UDP provides no congestion protocol but this protocol needed in a congested state in which very little useful work is done.</li> <li>When there is a congested state, all the UDP packets wouldn't traverse from source to destination. This would in turn block the TCP packets.</li> <li>Although, reliability is something that can be implemented in the application itself while using UDP as the underlying protocol.</li> <li>QUIC is an example of such thing.</li> </ul>"},{"location":"notes/Transport%20layer/#udp-segment-structure","title":"UDP segment structure","text":"<ul> <li>Application data contains DNS query or response message or application data itself.</li> <li>UDP header has four fields, each of 2 bytes.</li> <li>Length field specifies the number of bytes in the UDP segment.</li> <li>Checksum field tells whether any error has occurred or not. </li> </ul>"},{"location":"notes/Transport%20layer/#checksum","title":"Checksum","text":"<ul> <li>Checksum is a method to check for any errors/if any bits are manipulated in the segment.</li> <li>First addition of the 16 bit words in the segment is done, Any overflow encountered is wrapped around.</li> <li>After getting the sum, 1's complement on the sum is performed. This resulting 16 bits are sent along with the other 16 bit words.</li> <li>The destination receives this segment and adds up these 16 bit words along with the checksum. If the result is just 16 1's, then there is no error. If there is a 0, then there is an error.</li> </ul> <p>But why does UDP need this error detection method? - No guarantee about error checking between source and destination - In router memory could destory bits. - UDP provides error checking on an end to end basis - Although UDP provides this error checking method, it doesn't provide any method to overcome it.</p> <p>OS fundamental end to end principle: Functions provided at the lower level maybe redundant or of little value when compared to the cost of providing them at the higher level.</p>"},{"location":"notes/Upper%20Layers%20in%20Detail/","title":"Upper Layers in Detail","text":"<p>Note that the things written here about the OSI model are also applicable in the TCP/IP model.</p>"},{"location":"notes/Upper%20Layers%20in%20Detail/#application-layer","title":"Application Layer","text":"<p>The application layer serves as the interface or portal for applications to communicate over networks. It provides services such as email, file transfer, and web browsing.</p>"},{"location":"notes/Upper%20Layers%20in%20Detail/#presentation-layer","title":"Presentation Layer","text":"<p>The presentation layer is responsible for making data presentable by handling data formats and encryption. It converts data into standardized formats such as PDF or HTML and ensures data security through encryption protocols like SSL.</p>"},{"location":"notes/Upper%20Layers%20in%20Detail/#session-layer","title":"Session Layer","text":"<p>The session layer facilitates communication between the source and destination while other layers perform their functions. It manages sessions between applications and provides services such as establishing, maintaining, and terminating connections.</p>"},{"location":"notes/Upper%20Layers%20in%20Detail/#transport-layer","title":"Transport Layer","text":"<p>The transport layer determines how data is delivered from the source to the destination. It selects appropriate protocols, such as TCP for reliable transmission or UDP for faster transmission. TCP ensures reliable delivery by waiting for acknowledgment, while UDP prioritizes speed over reliability.</p>"},{"location":"notes/Upper%20Layers%20in%20Detail/#tcp-vs-udp","title":"TCP vs UDP","text":"<ul> <li>TCP: Reliable transmission, waits for acknowledgment.</li> <li>UDP: Faster transmission, does not wait for acknowledgment.</li> </ul> <p>Example: YouTube uses TCP for sending web page data and switches to UDP for streaming videos to prioritize real-time delivery.</p>"},{"location":"notes/Upper%20Layers%20in%20Detail/#ports","title":"Ports","text":"<p>Ports are used at the transport layer to facilitate communication between devices. They allow the destination to provide different services on different ports.</p>"},{"location":"notes/Upper%20Layers%20in%20Detail/#purpose-of-ports","title":"Purpose of Ports","text":"<p>Ports enable multiple services to run on a single device by assigning unique port numbers to each service. For example, HTTPS traffic typically uses port 443, FTP uses port 21, and SSH uses port 22.</p>"},{"location":"notes/Upper%20Layers%20in%20Detail/#source-port-assignment","title":"Source Port Assignment","text":"<p>When a device communicates with another device, it is assigned a source port to allow the destination to communicate back. This assigned port, known as an ephemeral port, is chosen from the range of available ports (0-65,535).</p>"},{"location":"notes/Upper%20Layers%20in%20Detail/#ephemeral-port","title":"Ephemeral Port","text":"<ul> <li>An ephemeral port is a randomly assigned port used by the sender for communication.</li> <li>It allows the destination to reply to the sender's communication.</li> </ul> <p>Ports with numbers\u00a0<code>0-1023</code>\u00a0are called system or\u00a0well-known\u00a0ports; ports with numbers\u00a0<code>1024-49151</code>\u00a0are called user or\u00a0registered\u00a0ports, and ports with numbers\u00a0<code>49152-65535</code>\u00a0are called dynamic, private or\u00a0ephemeral\u00a0ports. Registered port numbers are currently assigned by the... IANA... and were assigned by... ICANN... before March 21, 2001, and were assigned by the... USC/ISI... before 1998.</p> <p>Example Communication: <code>your_ip_addr:ephemeral_port --&gt; known_ip_addr:443</code> (443 for HTTPS)</p> <p>Read more about ephemeral ports here.</p>"}]}